/**
 * ANTI-EXPLOIT STAMINA ABUSE SYSTEM
 * 
 * Prevents exploitation of:
 * - Sprint toggling: SprintToggleFrequency tracked, if > threshold in 5s, drain multiplier activates
 * - Shield spam: Repeated shield within 3s reduces balance temporarily
 * - Slide spam: Repeated slide increases recovery animation duration
 * - Press spam: Constant high press drains team stamina collectively
 * 
 * All systems are physics-consistent - no artificial slowdown.
 * Detection windows reset; effects fade naturally.
 */

import type {
  AntiExploitSystem,
  SprintToggleTracking,
  ShieldSpamTracking,
  SlideSpamTracking,
  PressSpamTracking,
} from '../types/simulation';

const SPRINT_TOGGLE_THRESHOLD = 5; // 5 toggles
const SPRINT_TOGGLE_WINDOW = 5000; // 5 seconds
const SPRINT_DRAIN_MULTIPLIER_BASE = 1.0;
const SPRINT_DRAIN_MULTIPLIER_ABUSE = 1.05; // +5% per extra toggle

const SHIELD_COOLDOWN = 3000; // 3 seconds between shields
const SHIELD_BALANCE_DEBUFF = 0.15; // 15% balance reduction
const SHIELD_SPAM_CONSECUTIVE_THRESHOLD = 3;

const SLIDE_COOLDOWN = 4000; // 4 seconds between slides
const SLIDE_RECOVERY_INCREASE = 0.5; // +50% recovery time
const SLIDE_SPAM_CONSECUTIVE_THRESHOLD = 2;

const PRESS_THRESHOLD = 8; // 8+ high-press actions per second (team total)
const PRESS_TEAM_FATIGUE_INCREASE = 0.03; // +3% team fatigue per second over threshold

export class AntiExploitStaminaSystem implements AntiExploitSystem {
  sprintTracking: Map<string, SprintToggleTracking> = new Map();
  shieldTracking: Map<string, ShieldSpamTracking> = new Map();
  slideTracking: Map<string, SlideSpamTracking> = new Map();
  pressTracking: Map<string, PressSpamTracking> = new Map();

  sprintToggleThreshold: number = SPRINT_TOGGLE_THRESHOLD;
  sprintDrainMultiplier: number = SPRINT_DRAIN_MULTIPLIER_BASE;
  shieldCooldown: number = SHIELD_COOLDOWN;
  shieldBalanceDebuffAmount: number = SHIELD_BALANCE_DEBUFF;
  slideRecoveryIncrease: number = SLIDE_RECOVERY_INCREASE;
  pressThreshold: number = PRESS_THRESHOLD;
  pressTeamFatigueIncrease: number = PRESS_TEAM_FATIGUE_INCREASE;

  /**
   * Handle sprint toggle abuse detection
   */
  handleSprintToggle(playerId: string): number {
    const now = Date.now();
    let tracking = this.sprintTracking.get(playerId);

    if (!tracking) {
      tracking = {
        playerId,
        toggleCount: 1,
        windowStart: now,
        windowDuration: SPRINT_TOGGLE_WINDOW,
      };
      this.sprintTracking.set(playerId, tracking);
      return 1.0; // Normal drain
    }

    // Check if within window
    if (now - tracking.windowStart < tracking.windowDuration) {
      tracking.toggleCount++;
    } else {
      // Reset window
      tracking.windowStart = now;
      tracking.toggleCount = 1;
    }

    // Calculate drain multiplier
    if (tracking.toggleCount > this.sprintToggleThreshold) {
      const excessToggles = tracking.toggleCount - this.sprintToggleThreshold;
      return SPRINT_DRAIN_MULTIPLIER_BASE + (excessToggles * SPRINT_DRAIN_MULTIPLIER_ABUSE);
    }

    return SPRINT_DRAIN_MULTIPLIER_BASE;
  }

  /**
   * Handle shield spam detection
   */
  handleShieldAction(playerId: string): number {
    const now = Date.now();
    let tracking = this.shieldTracking.get(playerId);

    if (!tracking) {
      tracking = {
        playerId,
        lastShieldTime: now,
        consecutiveShields: 1,
        balanceDebuff: 0,
      };
      this.shieldTracking.set(playerId, tracking);
      return 0; // No debuff first shield
    }

    const timeSinceLastShield = now - tracking.lastShieldTime;

    // Check if spamming (within cooldown)
    if (timeSinceLastShield < this.shieldCooldown) {
      tracking.consecutiveShields++;
      
      // Apply debuff if exceeding threshold
      if (tracking.consecutiveShields >= SHIELD_SPAM_CONSECUTIVE_THRESHOLD) {
        tracking.balanceDebuff = this.shieldBalanceDebuffAmount * 
          (tracking.consecutiveShields - SHIELD_SPAM_CONSECUTIVE_THRESHOLD + 1);
        tracking.balanceDebuff = Math.min(tracking.balanceDebuff, 0.6); // Cap at 60%
      }
    } else {
      // Reset consecutive counter
      tracking.consecutiveShields = 1;
      tracking.balanceDebuff = Math.max(0, tracking.balanceDebuff - 0.05); // Decay debuff
    }

    tracking.lastShieldTime = now;
    return tracking.balanceDebuff;
  }

  /**
   * Handle slide spam detection
   */
  handleSlideAction(playerId: string): number {
    const now = Date.now();
    let tracking = this.slideTracking.get(playerId);

    if (!tracking) {
      tracking = {
        playerId,
        lastSlideTime: now,
        consecutiveSlides: 1,
        recoveryAnimDuration: 0.6, // Default 600ms
      };
      this.slideTracking.set(playerId, tracking);
      return 0; // No increase first slide
    }

    const timeSinceLastSlide = now - tracking.lastSlideTime;

    // Check if spamming
    if (timeSinceLastSlide < SLIDE_COOLDOWN) {
      tracking.consecutiveSlides++;

      if (tracking.consecutiveSlides >= SLIDE_SPAM_CONSECUTIVE_THRESHOLD) {
        const excess = tracking.consecutiveSlides - SLIDE_SPAM_CONSECUTIVE_THRESHOLD;
        tracking.recoveryAnimDuration = 0.6 * (1 + this.slideRecoveryIncrease * (excess + 1));
        tracking.recoveryAnimDuration = Math.min(tracking.recoveryAnimDuration, 2.0); // Cap at 2 seconds
      }
    } else {
      // Reset
      tracking.consecutiveSlides = 1;
      tracking.recoveryAnimDuration = 0.6; // Reset to normal
    }

    tracking.lastSlideTime = now;
    return tracking.recoveryAnimDuration - 0.6; // Return increase amount
  }

  /**
   * Handle high press spam at team level
   */
  handleHighPress(teamId: string): number {
    const now = Date.now();
    let tracking = this.pressTracking.get(teamId);

    if (!tracking) {
      tracking = {
        teamId,
        pressFrequency: 1,
        teamFatigueFactor: 0,
      };
      this.pressTracking.set(teamId, tracking);
      return 0;
    }

    tracking.pressFrequency++;

    // If exceeding threshold, apply team fatigue penalty
    if (tracking.pressFrequency > this.pressThreshold) {
      const excess = tracking.pressFrequency - this.pressThreshold;
      tracking.teamFatigueFactor = excess * this.pressTeamFatigueIncrease;
    }

    return tracking.teamFatigueFactor;
  }

  /**
   * Update tracking windows (call periodically, e.g., 1x per second)
   */
  updateTrackingWindows(deltaTime: number): void {
    const now = Date.now();

    // Update sprint tracking
    this.sprintTracking.forEach((tracking, playerId) => {
      if (now - tracking.windowStart > tracking.windowDuration) {
        // Window expired, can remove
        this.sprintTracking.delete(playerId);
      }
    });

    // Update shield tracking - decay debuff over time
    this.shieldTracking.forEach((tracking, playerId) => {
      tracking.balanceDebuff = Math.max(0, tracking.balanceDebuff - deltaTime * 0.1); // Decay by 10% per sec
      if (tracking.balanceDebuff <= 0 && now - tracking.lastShieldTime > SHIELD_COOLDOWN * 2) {
        this.shieldTracking.delete(playerId);
      }
    });

    // Update slide tracking
    this.slideTracking.forEach((tracking, playerId) => {
      if (now - tracking.lastSlideTime > SLIDE_COOLDOWN * 3) {
        this.slideTracking.delete(playerId);
      }
    });

    // Update press tracking
    this.pressTracking.forEach((tracking, teamId) => {
      // Decay frequency back to baseline
      tracking.pressFrequency = Math.max(0, tracking.pressFrequency - 2);
      tracking.teamFatigueFactor = Math.max(0, tracking.teamFatigueFactor - deltaTime * 0.05);
      
      if (tracking.pressFrequency === 0) {
        this.pressTracking.delete(teamId);
      }
    });
  }

  /**
   * Reset player exploit state (e.g., substitution, new half)
   */
  resetPlayerExploitState(playerId: string): void {
    this.sprintTracking.delete(playerId);
    this.shieldTracking.delete(playerId);
    this.slideTracking.delete(playerId);
  }

  /**
   * Reset team exploit state (new half, goal kick reset)
   */
  resetTeamExploitState(teamId: string): void {
    this.pressTracking.delete(teamId);
  }

  /**
   * Check if player is currently under exploit penalty
   */
  getPlayerExploitPenalty(playerId: string): {
    sprintMultiplier: number;
    shieldDebuff: number;
    slideRecoveryIncrease: number;
  } {
    return {
      sprintMultiplier: this.handleSprintToggle(playerId),
      shieldDebuff: this.shieldTracking.get(playerId)?.balanceDebuff || 0,
      slideRecoveryIncrease: this.slideTracking.get(playerId)?.recoveryAnimDuration || 0,
    };
  }

  /**
   * Get team exploit status
   */
  getTeamExploitPenalty(teamId: string): number {
    return this.pressTracking.get(teamId)?.teamFatigueFactor || 0;
  }

  /**
   * Clear all tracking (match end)
   */
  clearAllTracking(): void {
    this.sprintTracking.clear();
    this.shieldTracking.clear();
    this.slideTracking.clear();
    this.pressTracking.clear();
  }

  /**
   * Get exploit tracking stats for debugging
   */
  getTrackingStats(): Record<string, any> {
    return {
      sprintTrackingPlayers: this.sprintTracking.size,
      shieldTrackingPlayers: this.shieldTracking.size,
      slideTrackingPlayers: this.slideTracking.size,
      pressTrackingTeams: this.pressTracking.size,
      totalActiveTracking: 
        this.sprintTracking.size + 
        this.shieldTracking.size + 
        this.slideTracking.size + 
        this.pressTracking.size,
    };
  }
}
